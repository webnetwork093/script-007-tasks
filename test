class Miracle():
    __slots__ = ("x", "y")
    # тут слотс по сути переопределяет х и у - она становятся методами-дескрипторами (сеттерами и геттерами)
    # для обращения и изменения самих себя во всех экземплярах класса. причем походу сами переменные х и у
    # становятся как бы "приватными", опеределить их прямо теперь нельзя


    def __init__(self, *args, **kwargs):
        self.x = 10 # тут мы указываем что переменные х и у для каждого экземпляра класса должны быть свои
        self.y = 11


m = Miracle()  # создал экземпляр класса
print(m.x, m.y)  # распечатал
# 10 11
n = Miracle()
print(n.x, n.y)  # распечатал
# 10 11

print(m.__slots__[0]) # оно теперь элемент массива
# x
print(n.__slots__[1])
# y

print(">>>" + str(Miracle().x))  # со скобками вернет 10, т.к. снова создаст экземпляр класса и обратится к переменной

print(">>>" + str(Miracle.x))  # а без скобок принтует <member 'x' of 'Miracle' objects> -
# тоесть сообщает, что тут х у нас тупо член обьектов типа Miracle, тобишь дескриптор

Miracle.x = 100  # тут он х во ВСЕХ экземплярах Miracle установит 100, т.к. х - общий дескриптор для всех экземпляторов
                 # (если эту строку закоментить то код исполнится без ашипок)
print(">>>" + str(Miracle.x)) # БОЛЬШЕ НЕ <member 'x' of 'Miracle' objects> а 100 во всех экземплярах класса,
                              # таким образом он больше не дескриптор!
# >>>100

print("m.x, m.y: ", m.x, m.y)
# 100 11
print("n.x, n.y: ", n.x, n.y) # тут n.x тоже стала соткой, т.к. дескриптор общий для всех экземплятор класса
# 100 11

m.x = 10  # а тут он теперь пишет ошибку, потому что изменение ставшей приватной переменной икс, которая первоначально
# благодаря slots была переопределена как дескриптор для обращения к самой себе, должно происходить
# с помощью метода set() из дескриптора, но здесь дескриптор то переписан
# и set не используется, таким образом изменение переменной таким образом стало недоступно

# AttributeError: 'Miracle' object attribute 'x' is read-only
m.y = 12

print(m.x, m.y)
